Phase:	ClauseSplit
Input:  Token Split Sentence
Options: control = appelt



MACRO: TWO_TOKEN_WINDOW
(
	(
		{Token.category =~ "^JJ|IN|RB|WD|WR|WP"}
	)[0, 2]
)


MACRO: NP
(
	( {Token.category =~ "^PRP"} )
	|
	(
		({Token.category == DT})?
		({Token.category =~ "^RB"})?
		({Token.category =~ "^JJ"})[0, 4]
		({Token.category =~ "^NN"})[1, 4]
	)
	|
	(
		{Token.category == DT}
		({Token.category =~ "^RB"})?
		({Token.category =~ "^JJ"})
	)
)


MACRO: NNP
(
	( {Token.category =~ "^PRP"} )
	|
	(
		({Token.category == DT})?
		({Token.category =~ "^RB"})?
		({Token.category =~ "^JJ"})[0, 4]
		({Token.category =~ "^NNP"})[1, 4]
	)
)


MACRO: PP
(
	(NP)
	{Token.category == IN}
	((NP) | (NNP))
)


MACRO: VG
(
	({Token.string ==~ "(?i)to"})?
	(
		({Token.category ==~ "VB|VBD|VBN|VBP|VBZ"}) |
		(
			{Token.category =~ "^MD"}
			{Token.category ==~ "VB|VBD|VBN|VBP|VBZ"}
		)
	)
)


MACRO: VB
(
	({Token.string ==~ "(?i)to"})?
	(
		({Token.category =~ "^VB"}) |
		(
			{Token.category =~ "^MD"}
			{Token.category =~ "^VB"}
		)
	)
)




Rule: MatchClauseSplit1
(
	(
		{Token.string ==~ ","}
	):c
	({Token.category ==~ "CC"})?
	(VB)?
	(TWO_TOKEN_WINDOW)
	(NP|PP)[1, 2]
	({Token.category ==~ "IN|CC|RB"})?
	(VB)
)
-->
:c.ClauseSplit={type=commanolist}



Rule: MatchClauseSplit1a
(
	(
		{Token.string ==~ ","}
	):c
	{Token.category ==~ "CC"}
	(VB)
	(TWO_TOKEN_WINDOW)
	(NP|PP)[1, 2]
)
-->
:c.ClauseSplit={type=commanolist}


Rule: MatchClauseSplit1b
(
	(
		{Token.string ==~ ","}
	):c
	(VB)
	(TWO_TOKEN_WINDOW)
	(NP|PP)[1, 2]
	{Token.category ==~ "RB|JJ"}
)
-->
:c.ClauseSplit={type=commanolist}


Rule: MatchClauseSplit1c
(
	(
		{Token.string ==~ ","}
	):c
	{Token.category ==~ "TO|MD"}
	(TWO_TOKEN_WINDOW)
	{Token.category =~ "^VB"}
)
-->
:c.ClauseSplit={type=commanolist}



Rule: MatchClauseSplit2
(
	{Token.category != "MD"}
	({Token.category ==~ "CC"}):c
	(TWO_TOKEN_WINDOW)
	(NP|PP)[0, 2]
	({Token.category ==~ "IN"})?
	(VG)
)
-->
:c.ClauseSplit={type=cc}


Rule: MatchClauseSplit2a
(
	({Token.string ==~ "(?i)but|although|however"}):c
)
-->
:c.ClauseSplit={type=cc}


Rule: MatchClauseSplit3
(
	({Token.category ==~ "IN"})[1,2]:c
	(NNP)[1, 2]
	({Token.category ==~ "IN"})?
	(VG)
)
-->
:c.ClauseSplit={type=pp}




Rule: MatchClauseSplit4
(
	(
		{Token.string ==~ ","}
	):c
	{Token.category ==~ "IN|RB"}
)
-->
:c.ClauseSplit={type=commafor}


Rule: MatchClauseSplit4a
(
	{Token.category ==~ "IN|RB"}
	(
		{Token.string ==~ ","}
	):c
)
-->
:c.ClauseSplit={type=forcomma}



Rule: MatchClauseSplit5
(
	{Token.string ==~ "[;:]"} |
	{Token.kind == punctuation, Token.subkind == dashpunct}
):c
{!Token.kind == punctuation}
-->
:c.ClauseSplit={type=punct}



Rule: MatchClauseSplit6
(
	{Token.category !=~ "IN|TO", Token.category !~ "^VB"}
	({Token.category =~ "^WD|WR|WP"}):c
)
-->
:c.ClauseSplit={type=wh}


Rule: MatchClauseSplit6a
(
	({Token.category == "IN"}):c
	{Token.category =~ "^WD|WR|WP"}
)
-->
:c.ClauseSplit={type=wh}


Rule: MatchClauseSplit6b
(
	(VG)
	({Token.category ==~ "IN", Token.string ==~ "(?i)that|which"}):c
	{Token.kind == word}
)
-->
:c.ClauseSplit={type=wh}



Rule: MatchClauseSplit7
(
	{Token.category !~ "^VB|IN|WR"}
	({Token.category =~ "^RB"}):c
	(VG)?
	(TWO_TOKEN_WINDOW)
	(NP|PP)[1, 2]
	(TWO_TOKEN_WINDOW)
	(VG)
)
-->
:c.ClauseSplit={type=rb}


